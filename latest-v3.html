<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>UV Index - Hourly Bar & 5-Day</title>
<style>
/* ... senin css kodların aynı bırakıldı ... */
</style>
</head>
<body>

<div class="card">
  <div style="display:flex;justify-content:space-between;align-items:center">
    <div>
      <div class="small" id="uv-label">Current UV Index</div>
      <div class="uv-circle">
        <svg width="120" height="120">
          <circle class="bg" r="54" cx="60" cy="60"></circle>
          <circle class="fg" r="54" cx="60" cy="60"></circle>
        </svg>
        <div class="uv-value" id="uv">--</div>
      </div>
      <div id="desc" class="small">Waiting for data</div>
    </div>
    <div style="text-align:right">
      <div class="small">Location:</div>
      <div id="coords" class="small">—</div>
    </div>
  </div>

  <hr style="margin:14px 0">

  <div class="small">Enter coordinates (lat,lon) or use location:</div>
  <input id="manual" placeholder="e.g., 39.92,32.85 or leave empty" />
  <div style="display:flex;gap:8px;margin-top:8px">
    <button class="btn" id="geo">Use My Location</button>
    <button class="btn" id="check">Fetch UV</button>
  </div>
</div>
<div style="font-size:14px; color:#555; margin-top:6px; text-align:center;">
  For accurate UV Index data, please allow location access in your browser.
</div>

<div class="daily-buttons" id="daily-buttons"></div>

<h3 style="text-align:center; margin-top:10px;">Hourly UV Index (UTC)</h3>
<div class="hourly-bar-container" id="hourly-bars"></div>
<div class="hour-labels" id="hour-labels"></div>

<h3 style="text-align:center; margin-top:30px">UV Index Reference</h3>
<div class="uv-scale">
  <!-- ... senin referans ölçek kısmın aynı bırakıldı ... -->
</div>

<script>
const uvEl = document.getElementById('uv');
const descEl = document.getElementById('desc');
const coordsEl = document.getElementById('coords');
const manual = document.getElementById('manual');
const fgCircle = document.querySelector('.fg');
const hourlyBars = document.getElementById('hourly-bars');
const hourLabels = document.getElementById('hour-labels');
const dailyButtonsContainer = document.getElementById('daily-buttons');
const uvLabelEl = document.getElementById('uv-label');

let uvData = null;
let timesData = null;
let selectedDayIndex = 0;

function uvCategory(val){
  if(val===null||val===undefined) return 'Unknown';
  if(val<3) return 'Low';
  if(val<6) return 'Moderate';
  if(val<8) return 'High';
  if(val<11) return 'Very High';
  return 'Extreme';
}
function uvColor(val){
  if(val<3) return '#a8e05f';
  if(val<6) return '#fdd835';
  if(val<8) return '#f97306';
  if(val<11) return '#ef4444';
  return '#9b30ff';
}

async function fetchUV(lat, lon){
  uvEl.textContent='...';
  descEl.textContent='Fetching data';
  coordsEl.textContent=`${lat.toFixed(5)}, ${lon.toFixed(5)}`;

  try{
    const res = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=uv_index&timezone=UTC`);
    if(!res.ok) throw new Error('API error: '+res.status);
    const data = await res.json();

    timesData = data.hourly.time || [];
    uvData = data.hourly.uv_index || [];

    renderDailyButtons(timesData);
    renderHourlyBarsForDay(selectedDayIndex);
    updateCurrentUV(selectedDayIndex);

  }catch(err){
    uvEl.textContent='Error';
    descEl.textContent=err.message;
  }
}

function renderDailyButtons(times){
  dailyButtonsContainer.innerHTML = '';
  let days = [];
  for(let t of times){
    const d = t.slice(0,10);
    if(!days.includes(d)) days.push(d);
    if(days.length >=5) break;
  }

  days.forEach((d,i)=>{
    const dt = new Date(d);
    const options = {weekday:'short', day:'numeric', month:'short'};
    const label = dt.toLocaleDateString('en-US',options);
    const btn = document.createElement('button');
    btn.textContent = label;
    if(i===selectedDayIndex) btn.classList.add('active');
    btn.onclick = ()=>{
      selectedDayIndex=i;
      document.querySelectorAll('.daily-buttons button').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      renderHourlyBarsForDay(i);
      updateCurrentUV(i);
    };
    dailyButtonsContainer.appendChild(btn);
  });
}

function renderHourlyBarsForDay(dayIndex){
  hourlyBars.innerHTML='';
  hourLabels.innerHTML='';
  if(!uvData || !timesData) return;

  const daysUnique = [...new Set(timesData.map(t=>t.slice(0,10)))];
  const selectedDayStr = daysUnique[dayIndex];

  const dayTimes = timesData.map((t,idx)=>({t: new Date(t+'Z'), uv: uvData[idx]}))
    .filter(x => x.t.toISOString().slice(0,10) === selectedDayStr);

  for(let j=0;j<dayTimes.length;j++){
    const tObj = dayTimes[j];
    const uv = tObj.uv;
    const color = uvColor(uv);
    const heightPercent = Math.min((uv/11)*100,100);
    const bar = document.createElement('div');
    bar.className='hourly-bar';
    bar.style.height='100%';
    bar.innerHTML=`<span>${uv}</span><div style="background:${color}; height:${heightPercent}%; width:100%; border-radius:4px 4px 0 0"></div>`;
    hourlyBars.appendChild(bar);

    const label = document.createElement('div');
    label.textContent = tObj.t.getUTCHours();
    hourLabels.appendChild(label);
  }
}

function updateCurrentUV(dayIndex){
  if(!uvData || !timesData) return;
  const daysUnique = [...new Set(timesData.map(t=>t.slice(0,10)))];
  const selectedDayStr = daysUnique[dayIndex];
  const now = new Date();
  const currentHour = now.getUTCHours();

  let chosenIdx = null;

  if(dayIndex === 0){
    // Bugün: en yakın saate bak
    let minDiff = Infinity;
    timesData.forEach((t,idx)=>{
      if(t.slice(0,10)===selectedDayStr){
        const dt = new Date(t+'Z');
        const diff = Math.abs(dt - now);
        if(diff < minDiff){
          minDiff = diff;
          chosenIdx = idx;
        }
      }
    });
    uvLabelEl.textContent = "Current UV Index";
  } else {
    // Yarın veya sonrası: o günün currentHour değerini al
    timesData.forEach((t,idx)=>{
      if(t.slice(0,10)===selectedDayStr){
        const dt = new Date(t+'Z');
        if(dt.getUTCHours() === currentHour){
          chosenIdx = idx;
        }
      }
    });
    uvLabelEl.textContent = "Predicted UV Index";
  }

  if(chosenIdx === null) return;

  const uvVal = uvData[chosenIdx];
  uvEl.textContent = uvVal.toFixed(1);
  descEl.textContent = uvCategory(uvVal) + ` • Hour (UTC): ${timesData[chosenIdx].slice(11)}`;
  animateUVCircle(uvVal);
}

function animateUVCircle(uvVal){
  const maxVal = 11;
  const percent = Math.min(uvVal/maxVal,1);
  const dashOffset = 339.292*(1-percent);
  fgCircle.style.strokeDashoffset=dashOffset;
  fgCircle.style.stroke=uvColor(uvVal);
}

document.getElementById('geo').onclick = () => {
  if(!navigator.geolocation) return alert('Browser does not support geolocation API');
  navigator.geolocation.getCurrentPosition(p=>{
    manual.value = p.coords.latitude.toFixed(5)+','+p.coords.longitude.toFixed(5);
    fetchUV(p.coords.latitude,p.coords.longitude);
  }, e => alert('Could not get location: '+e.message));
};

document.getElementById('check').onclick = () => {
  const text = manual.value.trim();
  if(!text) return alert('Please enter lat,lon or use Get Location.');
  const parts = text.split(',').map(s=>s.trim());
  if(parts.length<2) return alert('Format: lat,lon (e.g., 39.92,32.85)');
  const lat=parseFloat(parts[0]), lon=parseFloat(parts[1]);
  if(isNaN(lat)||isNaN(lon)) return alert('Invalid coordinates');
  fetchUV(lat, lon);
};

manual.value='41.00824,28.97836';
fetchUV(41.00824,28.97836);
</script>
</body>
</html>
